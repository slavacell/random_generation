#include <iostream>
#include <vector>
#include <cmath>
//#include <math.h>
//#include <string>


//  объявляю пару переменных для использования епс - просто маленькое число, которое я так и не использзовал, пи - понятно
#define eps (0.1e-9)
#define pi (3.141592653589793)

//  чисто для удобства
using namespace std;


//   первый генератор случайных чисел. На вход получаем число в диапазоне от 0 до 1 на выходе так же
//   сам генератор даёт равномерное распределение значений в каждый интервал длиной 0.0001, меньше я не проверял, т.к этого уже достаточно мне, 
//   а также для проверки нужно генерировать оченьмного случайноых чисел + уже может подводить точность вычислений
double rand_1(double x)
{
    //   это будут случайные числа, потому что так почему-то происходит. Вбейте в интернет бифуркационная диаграмма и оттуда будет всё понятно
    x = (3.9 + (0.5 - x) / 10) * x * (10 - x);
    //   сами числа получаются слегака не полностью в диапазоне от 0 до 1 (не дотягивает до крайни значений) поэтому беру со второго знака
    x *= 10;
    //  превращение в положительное число от 0 до 1
    return fabs(x - int(x));
}


//   второй грч. На вход координаты х и у, сид и какое-то число к
double rand_2(double x, double y, double seed, double k)
{
    //  исполльзую тригонометрические функции, т.к очевидно мы будем получать хорошие случайные числа
    k = sin(109 * x + 113 * y + 103 * k);
    //  здесь аналогично, а также ещё на всякий я умножаю на пи
    k *= cos(seed) * pi;
    //  проверять, что генерация равномерная сложно, поэтому для перестраховки запускаю предыдущий алгоритм генерации 
    return rand_1(fabs(k - int(k)));
}


//  это обратная функция ошибок, она нужна для перевода вероятности в нормальном распределении
//  её реализации нет в библиотеке, поээтому скачал эту функцию с интернета. По тестам видно было, что отрабатывает хорошо
//  как работает функция я не знаю, комментарии там ещё с оригинала
double erfinv(double a)
{
    double p, r, t;
    t = fmaf(a, 0.0 - a, 1.0);
    t = log(t);
    if (fabs(t) > 6.125) { // maximum ulp error = 2.35793
        p =              3.03697567e-10; //  0x1.4deb44p-32
        p = fmaf (p, t,  2.93243101e-8); //  0x1.f7c9aep-26
        p = fmaf (p, t,  1.22150334e-6); //  0x1.47e512p-20
        p = fmaf (p, t,  2.84108955e-5); //  0x1.dca7dep-16
        p = fmaf (p, t,  3.93552968e-4); //  0x1.9cab92p-12
        p = fmaf (p, t,  3.02698812e-3); //  0x1.8cc0dep-9
        p = fmaf (p, t,  4.83185798e-3); //  0x1.3ca920p-8
        p = fmaf (p, t, -2.64646143e-1); // -0x1.0eff66p-2
        p = fmaf (p, t,  8.40016484e-1); //  0x1.ae16a4p-1
    } else { // maximum ulp error = 2.35002
        p =              5.43877832e-9;  //  0x1.75c000p-28
        p = fmaf (p, t,  1.43285448e-7); //  0x1.33b402p-23
        p = fmaf (p, t,  1.22774793e-6); //  0x1.499232p-20
        p = fmaf (p, t,  1.12963626e-7); //  0x1.e52cd2p-24
        p = fmaf (p, t, -5.61530760e-5); // -0x1.d70bd0p-15
        p = fmaf (p, t, -1.47697632e-4); // -0x1.35be90p-13
        p = fmaf (p, t,  2.31468678e-3); //  0x1.2f6400p-9
        p = fmaf (p, t,  1.15392581e-2); //  0x1.7a1e50p-7
        p = fmaf (p, t, -2.32015476e-1); // -0x1.db2aeep-3
        p = fmaf (p, t,  8.86226892e-1); //  0x1.c5bf88p-1
    }
    r = a * p;
    return r;
}


//   реализация структуры шума перлина. Это квадратное поле, где по определённой сетке генерируются случайные числа, которые потом сглаживаются с соседями
//   из-за разной комбинации получается разный красивый непредсказуемый плавный ландшафт (числа от 0 до 1)
struct perlin
{
    //  м - число слоёв в шуме с разной сеткой
    //  н - размер шума
    int m, n;
    //  сам массив значений
    vector<vector<vector<double>>> noise;
    //   массив сетки, который хранит количество генерируемых значений (ребро). Все числа должны делить число н нацело
    vector<int> grid;
    //   массив силы каждого слоя, т.е его вклад в общий результат. Сумма всех чисел должна быть равна 1
    vector<double> power;

    //  два способа создания шума в первом нам даётся количество, длина и массив сетки, во втром ещё массив сил (в первом силы одиноковы)
    //  генерируем м + 1 слой, чтобы в нём хранить уже среднее значение по всем слоям и размера н + 1, чтобы там сгенерировать случайные значения соседних шумов
    //  замечу заранее, что эти места мы используем только для хранения значений соседних шумов, т.е мы на этих участках ничего не сглаживем
    //  а также не выводим значение по ним (всё это будет ниже), потому что они не входят в нашу область генерации
    perlin(int M, int N, vector<int> G) : m(M), n(N), noise(M + 1, vector<vector<double>>(N + 1, vector<double>(N + 1, 0))), grid(G), power(m, double(1.0 / m)) {}
    perlin(int M, int N, vector<int> G, vector<double> P) : m(M), n(N), noise(M + 1, vector<vector<double>>(N + 1, vector<double>(N + 1, 0))), grid(G), power(P) {}

    //  эта функция генерирует сами случайные числа и расставлет их по сетке в каждом слое на вход получаем координаты, сид и некий коэффициент
    void generate(double x, double y, double seed, double k)
    {
        //  перебираем постепенно все слои шума перлина
        for (int i = 0; i < m; i++)
        {
            //   расстояние между числами в сетке (пример: на шум 16х16 генерируем сетку размером 2, т.е расстояние 8 => расположение чисел 
            //   по координатам 0 0,  0 8,  8 0,  8 8)
            int dn = n / grid[i];
            //   пользуемся генератором и производим с числом к какие-то странные махинации, чтобы самое первое число в шуме на каждом слое было разным
            double a = rand_2(x, y, seed, k * (1 + sin(i)));
            //   цикл по узлам сетки
            for (int j = 0; j < grid[i]; j++)
            {
                for (int jj = 0; jj < grid[i]; jj++)
                {
                    //   пользуюсь другим генератором подставляя туда предыдущее число (именно так он проверялся, поэтому распределение будет нормальным)
                    a = rand_1(a);
                    noise[i][j * dn][jj * dn] = a;
                }
            }

            //   текущий нашш шум надо сгладить с соседними в крайних точках, поэтому генерируем числа, которые бы мы получили вызвав эту функцию для того участка
            //  именно для этих значений размер шума на 1 больше
            a = rand_2(x + 1, y, seed, k * (1 + sin(i)));
            //   это генерация соседнего участка снизу
            for (int j = 0; j < grid[i]; j++)
            {
                a = rand_1(a);
                noise[i][n][j * dn] = a;
            }

            //  аналогично генерация углового элемента
            a = rand_2(x + 1, y + 1, seed, k * (1 + sin(i)));
            a = rand_1(a);
            noise[i][n][n] = a;

            //  аналогично генерация соседа справа
            a = rand_2(x, y + 1, seed, k * (1 + sin(i)));
            for (int j = 0; j < grid[i]; j++)
            {
                a = rand_1(a);
                noise[i][j * dn][n] = a;
                //  тут надо дополнительно запустить такой цикл. т.к значения в правом столбце я получаю только спустя некоторое число шагов, т.к заполняю сначала целиком строчку
                for (int jj = 0; jj < grid[i] - 1; jj++) {a = rand_1(a);}
            }
        }
    }

    //  фунция сглаживает наш шум, т.е мы запоняем его оставшиеся нулевые клетки числами
    void fill()
    {
        //  новые переменные для удобства
        int i_, j_, dn;
        double a1, a2, a3, a4;
        for (int k = 0; k < m; k++)
        {
            //  та самая ширина сетки
            dn = n / grid[k];
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    //  наша клетка попадает в какую-то область ограниченную 4 случайнми значениями. Сглаживание обычное равномерноеЖ (пусть 1 0 0 0 0 6
                    //  и мы равномерно заполняем оставшиеся клетки, т.е 1  2 3 4 5  6) двумерный случай аналогичен, я просто подсчитал всё на листике и получил
                    //  сразу готовый результат в данной точке от координат и значаний в соседних узлах сетки
                    a1 = noise[k][int(i / dn) * dn][int(j / dn) * dn];
                    a2 = noise[k][int(i / dn) * dn][int(j / dn) * dn + dn];
                    a3 = noise[k][int(i / dn) * dn + dn][int(j / dn) * dn];
                    a4 = noise[k][int(i / dn) * dn + dn][int(j / dn) * dn + dn];
                    i_ = dn - (i % dn); j_ = dn - (j % dn);
                    noise[k][i][j] = (a1 * i_ * j_ + a2 * i_ * (j % dn) + a3 * j_ * (i % dn) + a4 * (i % dn) * (j % dn)) / (dn * dn);
                }
            }
        }

        //  после сглаживания можно заполнить наш суммарный результат в тот самый слой, который мы дополнительно сгенерировали
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                for (int k = 0; k < m; k++)
                {
                    //   тут и идёт умножение значения числа в данном слое на силу этогго слоя
                    noise[m][i][j] += noise[k][i][j] * power[k];
                }
            }
        }

    }

    //   эта фунция очистки, она очищает слои, оставляя всё остальное без измменения, для дальнейшего использования генерации такого же типа
    //   эта функция сейчас вроде не используется в программме, но она есть
    void clear()
    {
        noise = vector<vector<vector<double>>>(m + 1, vector<vector<double>>(n + 1, vector<double>(n + 1, 0)));
    }

    //  тоже функция не используется, она позволяет пересоздать текущую переменную шума, на вход параметры как и при генерации
    void remake(int M, int N, vector<int> G)
    {
        m = M; n = N; grid = G;
        noise = vector<vector<vector<double>>>(M + 1, vector<vector<double>>(N + 1, vector<double>(N + 1, 0)));
        power = vector<double>(m, double(1.0 / m));
    }
    //  аналогично, но другой способ задания генерации
    void remake(int M, int N, vector<int> G, vector<double> P)
    {
        m = M; n = N; grid = G; power = P;
        noise = vector<vector<vector<double>>>(M + 1, vector<vector<double>>(N + 1, vector<double>(N + 1, 0)));
    }

    //  а вот и та самая функция вероятности. При сглаживании мы измменяем вероятность распредеоения случаной величины и теперь крайние значения достигаются ещё реже
    //  (очевидно, например, 0 будет только в узлах сетки) Мы будем получать нормальное распределение, для которого известен интеграл, можете вбить в википедию
    //  и посмотреть на него. Но в нашем случае мы хотим генерацию с вероятностью Р, т.е Р должно являться площадью под графиком, т.е значением интергала для 
    //  какой-то точки, которую мы и хотим найти, чтобы сравнивать с ней. Выразив формулу в обратную сторону мы получаем нечто, написанное после ретурна
    //  в формуле фигурируют математическое ожидание (очевидно 0.5), а также дисперсия, которая, что тоже очевидно, зависит от количеста слоёв в шуме
    //  она вычисляется в переменной д. ерфинв - та самая функция, которая нужна мне
    double p(double P)
    {
        //   если мы заполняли один слой хаотично в каждой точке, то мы ничего не сглаживали и вернём значение как и было
        if (m == 1 && grid[0] == n){return P;}

        double d = 0.1 / m / 2;
        return sqrt(2 * d) * erfinv(2 * P - 1) + 0.5;
    }
    //  можно было обойтись и без функции сверху, подбирая нужный коэффициент подбором, как подбирается сетка слоёв шума и их сила, но я решил написать

    //  функция возвращает значение шума в точке, дополнительно проверяя, что она лежит в необходимом диапазоне
    double get(double i, double j)
    {
        if (0 <= i && i < n && 0 <= j && j < n){return noise[m][i][j];}
        else {return 0;}
    }

    //   эта функция не использзуется, она просто выводила требуемый слой шума на экран, для поиска ошибок
    //   параметр фулл показывал, нужно ли выводить дополнительные граничные значения, т.е с соседних шумов
    void print(int k, int full)
    {
        if (full)
        {
            for (int i = 0; i < n + 1; i++)
            {
                cout << endl;
                for (int j = 0; j < n + 1; j++)
                {
                    cout << double(noise[k][i][j]) << " ";
                }
            }
            cout << endl;
        }
        else
        {
            for (int i = 0; i < n; i++)
            {
                cout << endl;
                for (int j = 0; j < n; j++)
                {
                    cout << double(noise[k][i][j]) << " ";
                }
            }
            cout << endl;
        }
    }
};

//   эта функция просто помогает генерировать строение. Она накладывает один массив на другой в необходиой точке
//   если часть накладываемого массива лежит мимо, то она не накладывается, также если число 0, то значит, что накладывать его не надо
void cover(vector<vector<int>>& a, int xa, int ya, vector<vector<int>> b, int xb, int yb, int X, int Y)
{
    for (int i = 0; i < xb; i++)
    {
        for (int j = 0; j < yb; j++)
        {
            if (b[i][j] != 0)
            {
                if (0 <= X + i && X + i < xa && 0 <= Y + j && Y + j < ya)
                {
                    a[X + i][Y + j] = b[i][j];
                }
            }
        }
    }
}

//  функция ззаменяет в массиве элемент по координатам, если элемент там равен А, иначе - ничего не происходит
void replace(vector<vector<int>>& a, int xa, int ya, int A, int B, int X, int Y)
{
    if (0 <= X && X < xa && 0 <= Y && Y < ya)
    {
        if (a[X][Y] == A)
        {
            a[X][Y] = B;
        }
    }
}


//  сама генерация моего мира, условия которого расписаны в реадми
//  на вход выводимый массив, диапазон чанков, начальные координаты и сид мира
void generate(vector<vector<int>>& M, int dx, int dy, int x, int y, int seed)
{
    //  генерация не отличается эффективным кодом, но для текущей задачи ничего страшного
    //  если вы хотите поиграться с шумом перлина, то оставляйте только эту группу циклов, остальные забаньте
    //  вы можете редактировать в генерации силу слоёв, их количество, сетку в них и вы также можете создать свои переменные
    //  в которые прогоните через функцию Р в структуре шума

    //  важное замечание, что в массиве м я храню код символа, а не сам символ, т.е 249, 250... это те числа, которые я захотел
    //  пишите в интренете таблица аскии и смотрите версии на все 256 символов, ставите подходящий для вас символ

    //  также важно, в своей реализации все объекты я генерировал на одном и том же участке, что и отрисовывал потом, что для других
    //  целей может не подойти. Лучше генирировать свой шум для каждой цели и накладывать требуемый кусок на текущую область
    for (int i = 0; i < dx; i++)
    {
        for (int j = 0; j < dy; j++)
        {
            //  я решил, что такая конфигурация сойдёт, хотя мне она не очень нравится, но подбирать такое это сложное дело
            perlin p(3, 24, {3, 4, 6}, {0.4, 0.3, 0.3});
            //  генерирую случайные значения по координатам данного чанка. к = 0.1 потому что я так решил
            p.generate(x / 24 + i, y / 24 + j, seed, 0.1);
            //  заполняем
            p.fill();
            //  требуемм аполнения 30 % (оно выполняется, но иногда кажется, что травы гораздо меньше)
            double p0 = p.p(0.3);
            //  заполняю каждую точку массива, так сказать биомом (земля трава)
            //  вообще для сложной генерации используйте два шума, один для температуры, другой для влажности и соотнесите
            //  на их комбинации и выбирайте подходящий биом
            for (int ii = 0; ii < 24; ii++)
            {
                for (int jj = 0; jj < 24; jj++)
                {
                    if (p.get(ii, jj) < p0){M[24 * i + ii][24 * j + jj] = 249;}
                    else{M[24 * i + ii][24 * j + jj] = 250;}
                }
            }
        }
    }
    //  генерация цветочков
    for (int i = 0; i < dx; i++)
    {
        for (int j = 0; j < dy; j++)
        {
            //  опять генерирую так называемые биомы
            perlin p(3, 24, {3, 4, 6}, {0.4, 0.3, 0.3});
            p.generate(x / 24 + i, y / 24 + j, seed, 0.1);
            p.fill();
            double p0 = p.p(0.3);

            //  на траве хаотично, поэтому шум с сеткой 24
            perlin a(1, 24, {24});
            a.generate(x / 24 + i, y / 24 + j, seed, 0.2);
            a.fill();
            double a0 = a.p(0.15);

            //  чтобы сделать кучнее, но не сплошное расположение цветков, используем сильный шум наряду с очень большими, чтобы добиться
            //  желаемого результата. Можно заметить, что кажется, что там не 5 процентов, но на самом деле в некотрых местах цветочков достаточно много
            //  надо было бы, наверное, использовать шумы 6 и 4, вместо 2, для более частых группировок
            perlin b(3, 24, {24, 3, 2}, {0.5, 0.25, 0.25});
            b.generate(x / 24 + i, y / 24 + j, seed, 0.2);
            b.fill();
            double b0 = b.p(0.05);

            //  здесь всё аналогично
            for (int ii = 0; ii < 24; ii++)
            {
                for (int jj = 0; jj < 24; jj++)
                {
                    if (p.get(ii, jj) < p0)
                    {
                        if (a.get(ii, jj) < a0){M[24 * i + ii][24 * j + jj] = 245;}
                    }
                    else
                    {
                        if (b.get(ii, jj) < b0){M[24 * i + ii][24 * j + jj] = 245;}
                    }
                }
            }
        }
    }

    //  это я использую для задания направления для выреза входа в здание
    //  вообще генерация здания неграмотная, но её достаточно дл данных целей, а вообще надо примерно так:
    //  берём какой-то массив куда сгенерируем структуру, мы её вставляем в центр и добавляем желание сгенерировать в ней дополнения
    //  все дополнения хранятся в массиве, и в они ссылаются на последующие дополнения, в итоге заполняем, пока есть участки генерации
    //  подобная генерация у меня есть в игре my_game, которая здесь выложена, но там очень сложно её найти в коде, но всё же, она там есть
    //  в начале файла можно будет увидеть сами комнаты генерации
    //  после чего повернём структуру если надо, и наложим готовую структуру на участок, который мы генерируем
    //  естественно нужно генерировать не только структуру в этом участке, но и в соседних, т.к они могут заходить, но можно урезать 
    //  диапазон генерации
    //  в реализации ниже домики могут перекрываться, причём это можно легко исправить, но я не хочу, т.к тогда не будет изюминки и приколов генерации
    vector<vector<int>> norm{{0, 1, -1, 0}, {1, 0, 0, -1}};

    for (int i = -1; i < dx + 1; i++)
    {
        for (int j = -1; j < dy + 1; j++)
        {
            //  опять биом
            perlin p(3, 24, {3, 4, 6}, {0.4, 0.3, 0.3});
            p.generate(x / 24 + i, y / 24 + j, seed, 0.1);
            p.fill();
            double p0 = p.p(0.3);

            //  новое случайное число для вероятности появления домика в сетке 24 на 24
            //  требовался один на 35 на 35, это как раз примерно шанс 47 процентов на участке 24 на 24
            double a = rand_2(x / 24 + i, y / 24 + j, seed, 0.3);
            if (a < 0.47)
            {
                //  генерируем координаты расположения в чанке от 0 до 23
                double X = 24 * rand_1(a), Y = 24 * rand_1(rand_1(a));
                X = int(X); Y = int(Y);
                //  располагаем домик
                cover(M, 24 * dx, 24 * dy, {{219, 219, 219, 219, 219},
                                            {219, 0, 0, 0, 219},
                                            {219, 0, 0, 0, 219},
                                            {219, 0, 0, 0, 219},
                                            {219, 219, 219, 219, 219}}, 5, 5, 24 * i + X - 2, 24 * j + Y - 2);
                //  перебираем всё внутри и вырезаем все цветочки, заменяя их на биом 
                for (int ii = 0; ii < 3; ii++)
                {
                    for (int jj = 0; jj < 3; jj++)
                    {
                        replace(M, 24 * dx, 24 * dy, 245, p.get(X - 1 + ii, Y - 1 + jj) < p0 ? 249 : 250, 24 * i + X - 1 + ii, 24 * j + Y - 1 + jj);
                    }
                }
                //  если мы на земле, то заполняем дом цветочками
                if (p.get(X, Y) >= p0)
                {
                    cover(M, 24 * dx, 24 * dy, {{245, 245, 245},
                                            {245, 0, 245},
                                            {245, 245, 245}}, 3, 3, 24 * i + X - 1, 24 * j + Y - 1);
                }
                //  вырезаем входную дверь для домика
                double b = 4 * rand_2(X, Y, seed, 0.4);
                replace(M, 24 * dx, 24 * dy, 219, p.get(X + norm[0][b] * 2, Y + norm[1][b] * 2) < p0 ? 249 : 250, 24 * i + X + norm[0][b] * 2, 24 * j + Y + norm[1][b] * 2);



            }
        }
    }
}


int main()
{
    //  делаем цикл, чтобы можно было наслаждаться вечно
    //  закрываем программу на крестик)
    //  про переменные я сказал в реадми, здесь скажу, что дх можно ставить большим, но не особо, ду не больше 7, т.к в консоль на полный экран
    //  не влезет столко символов на одной строке
    while (true)
    {
        int x, y, seed, dx, dy, s;
        cout << "dx dy x y seed /\n6 3 0 0 12346789 0\n";
        cin >> dx >> dy >> x >> y >> seed >> s;

        //  карта
        vector<vector<int>> M(dx * 24, vector<int>(dy * 24, 32));

        //  делаем генерацию
        generate(M, dx, dy, x, y, seed);

        // отображаем всё на экране
        for (int i = 0; i < dx * 24; i++)
        {
            for (int j = 0; j < dy * 24; j++)
            {
                cout << char(M[i][j]);
                if (s && j % 24 == 23){cout << " ";}
            }
            cout << endl;
            if (s && i % 24 == 23){cout << endl;}
        }
    }
    return 0;
}


